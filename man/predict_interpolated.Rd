% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prediction.R
\name{predict_interpolated}
\alias{predict_interpolated}
\title{Predict next word using Interpolation + IDF Reranking}
\usage{
predict_interpolated(
  input,
  tri_pruned,
  bi_pruned,
  uni_lookup,
  lambda = c(0.7, 0.25, 0.05),
  beta = 0.7,
  top_k = 3,
  top_uni = 500,
  penalize_stop = TRUE,
  idf_lookup = NULL
)
}
\arguments{
\item{input}{Character string. The input text to predict continuations for.}

\item{tri_pruned}{Data frame. Trigram model with columns: w1, w2, w3, p_cond}

\item{bi_pruned}{Data frame. Bigram model with columns: w1, w2, p_cond}

\item{uni_lookup}{Data frame. Unigram model with columns: word, p}

\item{lambda}{Numeric vector of length 3. Interpolation weights for [trigram, bigram, unigram]
(default: c(0.7, 0.25, 0.05)). Must sum to 1.0.}

\item{beta}{Numeric. IDF reranking exponent (default: 0.7). Higher values give more weight to rare words.}

\item{top_k}{Integer. Number of predictions to return (default: 3).}

\item{top_uni}{Integer. Maximum unigram candidates to consider (default: 500).}

\item{penalize_stop}{Logical. Whether to penalize stopwords in certain contexts (default: TRUE).}

\item{idf_lookup}{Data frame or NULL. Pre-computed IDF lookup table with columns (word, idf).
If NULL, will be computed from uni_lookup.}
}
\value{
Data frame with columns:
  \itemize{
    \item \code{word}: Predicted next word
    \item \code{p}: Interpolated probability 
    \item \code{score}: IDF-reranked score
    \item \code{source}: Highest contributing n-gram level
  }
}
\description{
Predicts the most likely next words using linear interpolation of n-gram probabilities
combined with IDF-based reranking for improved prediction quality. This algorithm
combines trigram, bigram, and unigram probabilities using weighted interpolation,
then reranks candidates using inverse document frequency to favor more informative words.
}
\examples{
\dontrun{
# Using default interpolation weights
predictions <- predict_interpolated(
  input = "I would like",
  tri_pruned = tri_model,
  bi_pruned = bi_model,
  uni_lookup = uni_model,
  top_k = 5
)

# Custom interpolation weights
predictions <- predict_interpolated(
  input = "Hello world",
  tri_pruned = tri_model,
  bi_pruned = bi_model, 
  uni_lookup = uni_model,
  lambda = c(0.6, 0.3, 0.1),
  beta = 0.8,
  top_k = 3
)
}

}
